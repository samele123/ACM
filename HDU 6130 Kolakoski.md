>  **[题目链接](http://acm.hdu.edu.cn/showproblem.php?pid=6130)**

#### <font color=blue>**题目意思**</font>
给你一个Kolakosiki 序列1,2,2,1,1,2,1,2,2,1,2,2,1,1,2,1,1,2,2,1……这个序列由1和2组成，相邻的相等的可以划分在一起，1,22,11,2,1,22,1,22,11,2,11,22,1……. 其中第i个模块的长度就是其中的数的个数。如对于上边的序列a[1]=1,a[2]=2,a[3]=2,a[4]=1……现在问你第n个数为什么。

#### <font color=blue>**解题思路**</font>
解释一下Kolakoski序列：

Kolakoski序列是一个仅由1和2组成的无限数列，是一种通过“自描述”来定义的数列[1]  。他的前几项为1,2,2,1,1,2,1,2,2,1,2,2,1,1,2,1,1,2,2,1,2,1,1,2,1,2,2,1,1,…(OEIS上的A000002)

它的定义很简单，若把数列中相同的数定为一组，令a(1)=1，a(2)=2，则a(n)等于第n组数的长度。
可以根据这个定义来推算第三项以后的数：例如由于a(2)=2，因此第2组数的长度是2，因此a(3)=2,；由于a(3)=2，所以第三组数的长度是2，因此a(4)=a(5)=1；由于a(4)=1，a(5)=1，所以第四组数和第五组数的长度都为1，因此a(6)=2，a(7)=1，以此类推。

由于这道题给的时间够，我们可以直接打表来求

#### <font color=blue>**代码部分**</font>

```
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
int a[100000007];
void work()
{
    int i,j;
    a[1]=1;
    a[2]=2;
    a[3]=2;
    a[4]=1;
    a[5]=1;
    for( i=6,j=4; i<10000007; j++)
    {
        if(a[j]==2)
        {
            if(a[i-1]==1)
            {
                a[i++]=2;
                a[i++]=2;
            }
            else if(a[i-1]==2)
            {
                a[i++]=1;
                a[i++]=1;
            }
        }
        else if(a[j]==1)
        {

            if(a[i-1]==1)
            {
                a[i++]=2;
            }
            else if(a[i-1]==2)
            {
                a[i++]=1;
            }
        }
    }
}
int main()
{
    int T;
    scanf("%d",&T);
    work();
    while(T--)
    {
        int n;
        scanf("%d",&n);
        printf("%d\n",a[n]);
    }
    return 0;
}

```